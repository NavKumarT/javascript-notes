THROTTLING — CORE IDEA
Throttling limits how often a function can execute.
Guarantee: function runs at most once every wait ms, no matter how many times it is triggered.

Use when you want controlled execution over time, not silence like debounce.

WHEN TO USE THROTTLING

Window scroll handlers

Resize events

Mouse move / touch move

Rate-limiting analytics events

Infinite scrolling

Game loops / animations (non-RAF)

Rule of thumb:

Debounce → wait until user stops

Throttle → keep running, but slowly

MENTAL MODEL (INTERVIEW GOLD)
Think of throttling as a gate with a timer.
Once the gate opens, it won’t open again until the timer expires.

Events may happen → function execution is rate-limited.

THROTTLE VS DEBOUNCE (1-LINE)
Throttle: “Run every N ms”
Debounce: “Run after silence of N ms”

TYPES OF THROTTLING

Leading edge (execute immediately)

Trailing edge (execute after delay)

Leading + trailing (most complex, most real-world)

Most interviews expect leading-edge throttle.

BASIC THROTTLE IMPLEMENTATION (LEADING EDGE)

function throttle(fn, wait) {
  let lastCallTime = 0;

  return function (...args) {
    const now = Date.now();

    if (now - lastCallTime >= wait) {
      lastCallTime = now;
      fn.apply(this, args);
    }
  };
}


Key points:

Uses timestamp comparison

No timers

Very predictable

Most efficient

WHY TIMESTAMP > setTimeout

No queued executions

No memory buildup

More deterministic under heavy load

Interview tip: timestamp-based throttling is preferred

TRAILING EDGE THROTTLE (EXECUTE LAST CALL)

function throttle(fn, wait) {
  let timeout = null;

  return function (...args) {
    if (!timeout) {
      timeout = setTimeout(() => {
        fn.apply(this, args);
        timeout = null;
      }, wait);
    }
  };
}


Behavior:

First call delayed

Ensures last invocation runs

Less common but sometimes required

LEADING + TRAILING THROTTLE (ADVANCED)

function throttle(fn, wait) {
  let lastCallTime = 0;
  let timeout = null;
  let lastArgs = null;

  return function (...args) {
    const now = Date.now();
    lastArgs = args;

    if (now - lastCallTime >= wait) {
      lastCallTime = now;
      fn.apply(this, args);
    } else if (!timeout) {
      const remaining = wait - (now - lastCallTime);

      timeout = setTimeout(() => {
        lastCallTime = Date.now();
        timeout = null;
        fn.apply(this, lastArgs);
      }, remaining);
    }
  };
}


This is what Lodash throttle does internally.

IMPORTANT GOTCHAS

this must be preserved → always use apply

Throttled functions may skip arguments

Trailing execution can cause unexpected state updates

Throttling ≠ performance optimization by default — use intentionally

THROTTLE + REQUESTANIMATIONFRAME (SCROLL BEST PRACTICE)

function throttleRAF(fn) {
  let isRunning = false;

  return function (...args) {
    if (isRunning) return;

    isRunning = true;
    requestAnimationFrame(() => {
      fn.apply(this, args);
      isRunning = false;
    });
  };
}


Best for:

Scroll-based UI updates

Visual changes

Avoids layout thrashing

REACT-SPECIFIC PITFALL
Bad:

window.addEventListener("scroll", throttle(handleScroll, 200));


Why bad:

New throttled function on every render

Correct:

const throttledScroll = useRef(throttle(handleScroll, 200));

useEffect(() => {
  window.addEventListener("scroll", throttledScroll.current);
  return () => window.removeEventListener("scroll", throttledScroll.current);
}, []);


INTERVIEW QUESTIONS & ANSWERS

Q: Does throttle guarantee execution?
A: Only if trailing edge is enabled.

Q: Is throttle synchronous or async?
A: Execution control is sync; delay uses async timers.

Q: Can throttle cause stale closures?
A: Yes, especially in React without refs.

Q: Throttle vs setInterval?
A: Throttle reacts to events; setInterval runs regardless of events.

ONE-LINE SUMMARY
Throttling enforces temporal control, not silence — it trades accuracy for stability.