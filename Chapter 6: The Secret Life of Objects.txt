Chapter 6: The Secret Life of Objects
This chapter details Object-Oriented Programming (OOP) in JavaScript, focusing on how objects serve as the central principle of program organization through encapsulation, polymorphism, and inheritance.

--------------------------------------------------------------------------------
1. Encapsulation and Interfaces
• Core Concept: Programs are organized into strictly separated Abstract Data Types (or object classes).
• Interface vs. Implementation: An object exposes an interface (a limited set of methods and properties) while hiding its complex internal code (encapsulation).
• Polymorphism: This allows code to work with different types of objects as long as they support the same interface (e.g., a toString method).
2. Methods and the this Binding
• Methods: These are simply properties that hold function values.
• The this Binding: When a function is called as a method (e.g., object.method()), the binding this automatically points to the object it was called on.
• Gotcha: Arrow Functions vs. Regular Functions:
    ◦ Regular functions have their own this binding based on how they are called.
    ◦ Arrow functions do not bind their own this; they see the this binding of the scope around them.
3. Prototypes
• Fallback Mechanism: When an object receives a request for a property it doesn't have, its prototype is searched, then the prototype’s prototype, and so on.
• The Root: Object.prototype is the root fallback for most objects.
• Object Creation: Use Object.create(proto) to create an object with a specific prototype.
• Overriding Gotcha: Adding a property to an object hides the property of the same name in its prototype (overriding).
4. Classes and Constructors
• Constructors: Functions used with the new operator. new creates a fresh instance, binds this to it, and sets its prototype to the constructor's prototype property.
• Class Notation: Introduced in 2015, the class keyword allows defining a constructor and methods together.
• Private Properties: Prefix a name with # to make it private; it is inaccessible outside the class declaration.
• Statics: Methods marked static are stored on the constructor itself, not the prototype, and cannot access class instances.
5. Maps and Symbols
• The "Plain Object as Map" Gotcha: Using {} as a map is dangerous because it inherits properties like toString from Object.prototype.
    ◦ Solutions: Use the Map class for any-type keys or Object.create(null) to create an object without a prototype.
• Symbols: Values created with Symbol() are unique and can be used as property names to avoid conflicts between different interfaces.
6. The Iterator Interface
• Iterables: Objects given to a for/of loop must have a method named with the Symbol.iterator symbol.
• Iterators: This method returns an object with a next() method, which returns {value, done}.
7. Inheritance
• Subclassing: Use extends to create a class based on another (superclass).
• super Keyword: In a constructor, super() must be called to initialize the superclass. super can also call methods on the superclass prototype.
• Controversy: Unlike encapsulation and polymorphism, inheritance is controversial because it tightly couples classes, increasing code "tangle".

--------------------------------------------------------------------------------
Tricky Interview Questions & "Gotchas"
1. Question: Why does typeof null return "object"?
    ◦ Answer: It is a historical accident in the language's design.
2. Question: What is the difference between Object.getPrototypeOf(obj) and the prototype property of a constructor?
    ◦ Answer: Object.getPrototypeOf(obj) returns the actual prototype of an instance. The prototype property on a constructor is the object that will be assigned as the prototype to instances created with new.
3. Question: Can you use this inside an arrow function used as a method?
    ◦ Answer: Yes, but it will refer to the this of the enclosing scope, not the object the method was called on, which often leads to bugs if not handled carefully.
4. Question: How do you create an object that has no prototype at all?
    ◦ Answer: Use Object.create(null). This is often done when using an object as a clean map.
5. Question: What does the instanceof operator do?
    ◦ Answer: It checks if an object derives from a specific class, following the inheritance chain (e.g., a Subclass instance is also an instance of Superclass).
Analogy: A class is like a blueprint for a machine. The interface is the set of buttons on the outside that the user sees; the encapsulated implementation is the complex wiring hidden inside the plastic shell.