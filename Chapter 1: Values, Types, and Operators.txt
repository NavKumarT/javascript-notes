Chapter 1: Values, Types, and Operators
This chapter introduces the "atomic elements" of JavaScript: the simple value types and the operators that act upon them.

--------------------------------------------------------------------------------
1. Values and Memory
• The Sea of Bits: Data is stored as long sequences of zeros and ones, called bits.
• Values: To manage these bits, they are separated into chunks called values, each of which has a type that determines its role.
• Volatility: Values are stored in computer memory; when a value is no longer used, it dissipates and its bits are recycled.

--------------------------------------------------------------------------------
2. Numbers
• Storage: JavaScript uses a fixed 64 bits to store a single number value.
• Precision Gotcha: While integers (whole numbers) are precise up to 9 quadrillion, fractional digital numbers are generally approximations, not precise values.
• Arithmetic Operators: Includes addition (+), subtraction (-), multiplication (*), division (/), and remainder (%).
• Precedence: Multiplication and division have higher precedence than addition and subtraction. When operators have the same precedence, they are applied left to right (e.g., 1 - 2 + 1 is (1 - 2) + 1).
• Scientific Notation: Very large or small numbers can be written using e (e.g., 2.998e8 is 299,800,000).

--------------------------------------------------------------------------------
3. Special Numbers
• Infinity: Includes both Infinity and -Infinity.
• The NaN Gotcha: NaN ("not a number") results from nonsensical computations like 0 / 0 or Infinity - Infinity.
    ◦ Crucial Interview Fact: NaN is technically a value of the number type.
    ◦ Identity Gotcha: NaN is the only value in JavaScript that is not equal to itself.

--------------------------------------------------------------------------------
4. Strings
• Notation: Strings can be enclosed in single quotes ('), double quotes ("), or backticks (`).
• Escaping: A backslash (\) indicates that the character following it has a special meaning (e.g., \n for a newline, \t for a tab).
• Concatenation: The + operator glues strings together.
• Template Literal Gotcha: Strings written with backticks can span multiple lines and embed expressions using ${}.
• Unicode/UTF-16: JavaScript uses 16 bits per string element. Gotcha: Some characters, like many emojis, take up two "character positions" in a string.

--------------------------------------------------------------------------------
5. Unary and Ternary Operators
• Unary: Operators that take only one value, such as typeof (which produces a string naming the type) or the minus operator when used to negate a number.
• Ternary (Conditional): The only operator that works on three values.

--------------------------------------------------------------------------------
6. Boolean Values and Logic
• Comparison: Binary operators like >, <, >=, <=, ==, and != result in a Boolean (true or false).
• Logical Operators:
    ◦ && (and): True only if both values are true.
    ◦ || (or): True if either value is true.
    ◦ ! (not): A unary operator that flips the value.

--------------------------------------------------------------------------------
7. Empty Values
• null and undefined: These denote the absence of a meaningful value.
• Gotcha: While their different meanings are an accident of JavaScript's design, they are mostly interchangeable in practice.

--------------------------------------------------------------------------------
8. Automatic Type Conversion (Type Coercion)
JavaScript is "ridiculously liberal" and will quietly convert types when an operator is applied to the "wrong" value.
• Gotcha Rules:
    ◦ "5" - 1 → 4 (string converts to number).
    ◦ "5" + 1 → "51" (number converts to string because + prefers concatenation).
    ◦ 8 * null → 0 (null becomes 0).
    ◦ false == 0 → true.
• Equality Gotcha: When types differ, null == undefined is true, but null == 0 is false.
• Best Practice: Use Strict Equality (=== and !==) to prevent unexpected type conversions.

--------------------------------------------------------------------------------
9. Short-Circuiting Operators
• || (OR): Returns the original left-hand value if it can be converted to true, otherwise returns the right.
    ◦ Falsy values: 0, NaN, and "" (empty string) count as false.
• ?? (Nullish Coalescing): Returns the right-hand value only if the left is null or undefined. This is safer when you want to treat 0 or "" as valid values.
• && (AND): Returns the left-hand value if it converts to false, otherwise returns the right.
• Short-circuit Evaluation: The right-hand side is only evaluated if necessary. For example, true || X will never evaluate X.

--------------------------------------------------------------------------------
Analogy for Type Coercion: Think of JavaScript as an over-eager translator. If you try to add a word (string) to a number, rather than telling you it doesn't make sense, the translator frantically guesses and turns everything into a single language (usually strings or numbers) just to keep the conversation moving